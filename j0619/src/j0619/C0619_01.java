package j0619;
public class C0619_01 {
	public static void main(String[] args) {
		/* 객체 지향 프로그래밍  - java   
			1. 추상화 2. 상속	3. 다형성 4. 캡슐화 */	
		
		// 1. 추상화 
		// 객체의 공통적인 속성과 기능을 추출해서 정의하는것을 의미함
		// 인터페이스에는 추상메서드나 상수를 통해 어떤 객체가 수행해야하는 역할만을 규정해줌
		// 실질적 구현은 해당인터페이스를 구현하는 각각의 객체들에서 하도록 
		// 프로그램을 설계하는 것을 의미한다. 
		
		// 인터페이스 - 역할(껍데기)과 구현을 분리.
		// 보다 유연함. 변경에 열려있는 프로그램을 설계할 수 있음. 
		// 역할에 해당하는 부분이 인터페이스를 통해 추상화가 될 수 있음 
		
		// 움직이는 것 - 전진, 후진 기능이있다. 
		//       구현부분 자동차   - 자동차가 앞으로가는것
		//              오토바이  - 오토바이가 앞으로가는것
		
		// 객체 생성 
		Car car = new Car(); // 기본생성자로 객체 생성
		MoterBike bike = new MoterBike(); 
		// 클래스명 참조변수명 = new 생성자();  로 객체를 생성함. 
		
		
		// 2. 상속 - 
		// 기존의 클래스를 재활용해서 새로운 클래스를 작성하는 문법적 요소 
		// 클래스간 공유될 수 있는 기능을 상위클래스로 추상화시켜
		// 해당 상위 클래스로부터 확장된 여러 하위클래스들이 모두 상위 클래스의 
		// 속성과 기능을 간편히 사용할 수 있도록 함. 
		
		// 상속을 받았기 때문에 부모의 인스턴스 변수를 가짐
		car.color = "빨간색"; // 부모의 인스턴스변수
		car.model = "소나타"; 
		car.startEngine(); // 부모클래스의 메서드 
		car.openWindow("앞 왼쪽");
		
		// Car, MoterBike의 공통적인 속성과 기능을 추출(추상화) 하여 
		// 상위클래스에 정의하고 extends를 통해 하위클래스를 확장해서
		// 해당 기능과 속성을 매번 반복적으로 적어야하는 번거러움 제거 
		// 각각 클래스에 특징에 맞게 메서드 오버라이딩을해서 내용 재정의 
		
		// 상속 : 하위클래스에서 그대로 받아 사용하거나 오버라이딩으로 선택적 재정의
		// 인터페이스 구현 : 반드시 추상메서드의 내용을 하위클래스에서 정의 
		
		
		// 3. 다형성 
		// 어떤 객체의 속성이나 기능이 상황에따라 여러가지 형태를 가질 수 있는 성질을 의미
		// 어떤 객체의 속성이나 기능이 다른역할을 수행할 수 있는 특성 - 오버라이딩, 오버로딩
		
		// 객체지향에서 다형성은 한 타입의 참조변수를 통해 여러타입의 객체를 참조할 수 있는것
		// 즉, 상위 클래스타입의 참조변수로 하위클래스 객체를 참조할 수 있는것. 
		
		// 이동수단은 자동차가될수도 잇고 오토바이가 될수도 있다. 
		// 다형성을 활용해 객체 생성하는 방식 
		// 상위클래스 VehicleH로 하위클래스(Car, MoterBike) 의 객체를 참조함
		VehicleH car1 = new Car();
		VehicleH bike1 = new MoterBike();
		// 부모클래스의 객체 배열을 생성 
		VehicleH[] vs = new VehicleH[2] ; 
		// VehicleH을2개만 담을 수 있는배열
		vs[0] = new Car();
		vs[1] = new MoterBike();
		for(VehicleH v : vs) {  // 간단for문
			System.out.println(v);
		}
		// 상위클래스 VehicleH 타입의 객체배열을 생성해주면 
		// 상속관계에 있는 모든 하위클래스를 담을 수 있음. 
		// 원래 자바에서 배열은 한가지 타입만 담을수 있는 자료구조인데 
		// 다형성을 활용하면 여러타입을 담을 수 있어 보다 유연하게 코드작성이 가능함
		
		Driver d = new Driver();
		d.drive(vs[0]); // 자동차
		d.drive(vs[1]); // 오토바이 
		
		
		// 4. 캡슐화  - 접근제어자를 활용. 클래스멤버들을 외부에서접근못하도록함. 
		// 클래스안에 속성과 기능을 하나의 캡슐로 만들어 데이터를 외부로부터 보호하는 것.
		// 데이터보호 - 외부로부터 클래스의 정의된 속성, 기능들을 보호
		// 데이터은닉 - 내부의 동작을 감추고 외부에는 필요한부분만노출 
		
		// 즉, 외부로부터 클래스에 정의된속성과 기능을 보호하고
		// 필요한부분만 노출해서 각 객체 고유의 독립성과 책임영역을 안전하게 지키자. 
		
		// private변수로 설정이 되어서 직접 수정 불가능
		// d.name = "홍길동";
		// d.setName("홍길동"); // public한 메서드를 통해서 변경 
		
		// getter & setter가 없다면 
		// 객체를 생성할때만 변수를 초기화 할 수 있음 
		Driver kang = new Driver("강백호", car);
		
		kang.drive();
		// > car의 operate()를 호출해서 실행시킴 
		// 캡슐화를 활용하면 , 객체 내부 동작을 외부에 노출하는것을 최소화해서
		// 각 객체의 자율성을 높이고 이를 통해서 결합도를 낮춘다. 
		
		
	}

}